/**
 * Copyright (C) 2022 Carnegie Mellon University
 *
 * This file is part of the HTTP course project developed for
 * the Computer Networks course (15-441/641) taught at Carnegie
 * Mellon University.
 *
 * No part of the HTTP project may be copied and/or distributed
 * without the express permission of the 15-441/641 course staff.
 */


%{
#include <unistd.h>

/* This file is generated by yacc */
#include "y.tab.h"


/* Define LEXDEBUG to enable debug messages for this lex file */
#define LEXDEBUG
#ifdef LEXDEBUG
#include <stdio.h>
#define LPRINTF(...) printf(__VA_ARGS__)
#else
#define LPRINTF(...)
#endif

#undef YY_INPUT
/*
 * yylex() by default takes input from stdin. You might be wondering how
 * to parse data from a buffer instead. This is how you do it. The way
 * it works is, when yylex() needs more input, it invokes a macro
 * called YYINPUT:
 *
 * YY_INPUT(lex_internal_buffer, number_of_bytes_read, max_number_of_bytes_to_read)
 *
 * We hack it, and we undef the macro, and redefine it to something else!
 *
 * The usage of this macro will be clear from the lex-yacc-example.
 */

/* We need some global state (must be defined in parser.y) */
extern char *parsing_buf;	/* The buffer to read the data from */
extern size_t parsing_buf_siz;	/* Size of the buffer */
extern int parsing_offset;	/* Current offset in the buffer */

#define MIN(__a, __b) (((__a) < (__b)) ? (__a) : (__b))

/* Redefine YY_INPUT to read from a buffer instead of stdin! */
#define YY_INPUT(__b, __r, __s) do {					\
		__r = MIN(__s, parsing_buf_siz - parsing_offset);	\
		memcpy(__b, parsing_buf + parsing_offset, __r);		\
		parsing_offset += __r;					\
	} while(0)



%}

/*
 * Following is a list of rules specified in RFC 2616 section 2:
 *
 * Lookup Table
 * cr              \x0d
 * lf              \x0a
 * sp              \x20
 * ht              \x09
 * quote           \"
 * digit           [0-9]
 * ctl             [\x0-\x1f\x7f]
 * upalpha         [A-Z]
 * loalpha         [a-z]
 * alpha	       [A-Za-z]
 * char            [\x0-\x7f]
 * octet           [\x0-\x1f\xff]
 * crlf            {cr}{lf}
 * lws             \x0d\x0a(\x20|\x09)*
 * hex             [ABCDEFabcdef0-9]
 * separators	   [\{\}\(\)\<\>@,;:\\\"/\[\]?=\x20\x09]
 */

/**
 * Declarations
 */
uphex       [A-F]
lohex       [a-f]

upalpha     [A-Z]
loalpha     [a-z]

digit		[0-9]

cr          \x0d
lf          \x0a

sp          \x20
ht          \x09

ctl	        [\x0-\x1f\x7f]

slash       [\/]
dot         [.]
colon       [:]
question    [?]
asterisk    [*]
percent     [%]
plus        [+]
minus       [-]
at          [@]
semicolon   [;]
ampersand   [&]
equal       [=]
dollar      [$]
comma       [,]

mark_sep        [\(\)]

/* "(" | ")" | "<" | ">" | "@" | "," | ";" | ":" | "\" | <"> | "/" | "[" | "]" | "?" | "=" | "{" | "}" | SP | HT */
separators  [\(\)\<\>@\,;:\\\"\/\[\]?=\{\}\x20\x09]

mark_token      [-_.!~*']

/* <any CHAR except CTLs or separators> */
token       [\x0-\x7f]{-}[\x0-\x1f\x7f]{-}[\(\)\<\>@\,;:\\\"\/\[\]?=\{\}\x20\x09]

/* <any OCTET except CTLs, but including LWS> */
text        [\x0-\xff]{-}[\x00-\x08\x0b-\x0c\x0e-\x1f\x7f]

lws         (\x0d\x0a)?[\x20\x09]+

%%
%{
/*
 * Actions
 *
 * yytext: yytext is the "string" that matches a certain rule. For example,
 *         in the first rule 1: slash, you get the string that matched
 *         (in this case "/") in yytext.
 *
 * yylval: yylval is a variable used to communicate matched value in lex to
 *         yacc. yylval is a union of different types (please see parser.y)
 *         file for details.
 */
%}

{uphex} {
//    LPRINTF("t:uphex '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_uphex;
}

{lohex} {
//    LPRINTF("t:lohex '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_lohex;
}

{upalpha} {
//    LPRINTF("t:upalpha '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_upalpha;
}

{loalpha} {
//    LPRINTF("t:loalpha '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_loalpha;
}

{digit} {
//    LPRINTF("t:digit; '%d'\n", atoi(yytext));

    /* Copy character to yylval.i*/
    yylval.i = atoi(yytext);

    return t_digit;
}

{cr} {
//    LPRINTF("t:cr; \n");

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_cr;
}

{lf} {
//    LPRINTF("t:lf; \n");

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_lf;
}

{sp} {
//    LPRINTF("t:sp '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_sp;
}

{ht} {
//    LPRINTF("t:ht '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_ht;
}

{ctl} {
//    LPRINTF("t:ctl; \n");

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_ctl;
}

{slash} {
//    LPRINTF("t:slash '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_slash;
}

{dot} {
//    LPRINTF("t:dot '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_dot;
}

{colon} {
//    LPRINTF("t:colon '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_colon;
}

{question} {
//    LPRINTF("t:question '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_question;
}

{asterisk} {
//    LPRINTF("t:asterisk '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_asterisk;
}

{percent} {
//    LPRINTF("t:percent '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_percent;
}

{plus} {
//    LPRINTF("t:plus '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_plus;
}

{minus} {
//    LPRINTF("t:minus '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_minus;
}

{at} {
//    LPRINTF("t:at '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_at;
}

{semicolon} {
//    LPRINTF("t:semicolon '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_semicolon;
}

{ampersand} {
//    LPRINTF("t:ampersand '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_ampersand;
}

{equal} {
//    LPRINTF("t:equal '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_equal;
}

{dollar} {
//    LPRINTF("t:dollar '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_dollar;
}

{comma} {
//    LPRINTF("t:comma '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_comma;
}

{mark_sep} {
//    LPRINTF("t:mark_sep '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_mark_sep;
}

{separators} {
//    LPRINTF("t:separators '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_separators;
}

{mark_token} {
//    LPRINTF("t:mark_token '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_mark_token;
}

{token} {
//    LPRINTF("t:token '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_token;
}

{text} {
//    LPRINTF("t:text '%s'; \n", yytext);

    /* Copy character to yylval.i*/
    yylval.i = yytext[0];

    return t_text;
}

{lws} {
//    LPRINTF("t:lws '%s'; \n", yytext);

    strcpy(yylval.str, yytext);

    return t_lws;
}

%%

int yywrap(void) {
return 0; }
