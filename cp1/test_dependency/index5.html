<img src="image(12).png" alt="Liso the Friendly Web Server"></img>
<img src="image(13).png" alt="Liso the Friendly Web Server"></img>
<div id="rfc.section.6.6.1.p.5"><p>A sender that generates a Date header field <em class="bcp14">SHOULD</em> generate its field value as the best available approximation of the date and time of message generation. In theory, the date ought to represent the moment just before generating the message content. In practice, a sender can generate the date value at any time during message origination.</p></div><div id="rfc.section.6.6.1.p.6"><p>An origin server with a clock (as defined in <a href="##http.date" title="Date/Time Formats">Section 5.6.7</a>) <em class="bcp14">MUST</em> generate a Date header field in all <a href="##status.2xx" class="smpl">2xx (Successful)</a>, <a href="##status.3xx" class="smpl">3xx (Redirection)</a>, and <a href="##status.4xx" class="smpl">4xx (Client Error)</a> responses, and <em class="bcp14">MAY</em> generate a Date header field in <a href="##status.1xx" class="smpl">1xx (Informational)</a> and <a href="##status.5xx" class="smpl">5xx (Server Error)</a> responses.</p></div><div id="rfc.section.6.6.1.p.7"><p>An origin server without a clock <em class="bcp14">MUST NOT</em> generate a Date header field.</p></div><div id="rfc.section.6.6.1.p.8"><p>A recipient with a clock that receives a response message without a Date header field <em class="bcp14">MUST</em> record the time it was received and append a corresponding Date header field to the message's header section if it is cached or forwarded downstream.</p></div><div id="rfc.section.6.6.1.p.9"><p>A recipient with a clock that receives a response with an invalid Date header field value <em class="bcp14">MAY</em> replace that value with the time that response was received.</p></div><div id="rfc.section.6.6.1.p.10"><p>A user agent <em class="bcp14">MAY</em> send a Date header field in a request, though generally will not do so unless it is believed to convey useful information to the server. For example, custom applications of HTTP might convey a Date if the server is expected to adjust its interpretation of the user's request based on differences between the user agent and server clocks.</p></div></section><section id="field.trailer"><h4 id="rfc.section.6.6.2"><a href="##rfc.section.6.6.2">6.6.2.</a>&nbsp;<a href="##field.trailer">Trailer</a></h4><div id="rfc.section.6.6.2.p.1"><p>The "Trailer" header field provides a list of field names that the sender anticipates sending as trailer fields within that message. This allows a recipient to prepare for receipt of the indicated metadata before it starts processing the content.</p></div><div id="rfc.section.6.6.2.p.2"><pre class="inline prettyprint lang-ietf_abnf prettyprinted" style=""><span id="rfc.iref.g.49"></span><span id="rfc.iref.g.50"></span><span class="pln">  </span><a href="##field.trailer" class="smpl"><span class="typ">Trailer</span></a><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">#</span><a href="##fields.names" class="smpl"><span class="typ">field-name</span></a>
</pre></div><div id="rfc.section.6.6.2.p.3"><p>For example, a sender might indicate that a signature will be computed as the content is being streamed and provide the final signature as a trailer field. This allows a recipient to perform the same check on the fly as it receives the content.</p></div><div id="rfc.section.6.6.2.p.4"><p>A sender that intends to generate one or more trailer fields in a message <em class="bcp14">SHOULD</em> generate a <a href="##field.trailer" class="smpl">Trailer</a> header field in the header section of that message to indicate which fields might be present in the trailers.</p></div><div id="rfc.section.6.6.2.p.5"><p>If an intermediary discards the trailer section in transit, the <a href="##field.trailer" class="smpl">Trailer</a> field could provide a hint of what metadata was lost, though there is no guarantee that a sender of Trailer will always follow through by sending the named fields.</p></div></section></section></section><section id="routing"><h2 id="rfc.section.7"><a href="##rfc.section.7">7.</a>&nbsp;<a href="##routing">Routing HTTP Messages</a></h2><div id="rfc.section.7.p.1"><p>HTTP request message routing is determined by each client based on the target resource, the client's proxy configuration, and establishment or reuse of an inbound connection. The corresponding response routing follows the same connection chain back to the client.</p></div><section id="target.resource"><h3 id="rfc.section.7.1"><a href="##rfc.section.7.1">7.1.</a>&nbsp;<a href="##target.resource">Determining the Target Resource</a></h3><div id="rfc.section.7.1.p.1"><p>Although HTTP is used in a wide variety of applications, most clients rely on the same resource identification mechanism and configuration techniques as general-purpose Web browsers. Even when communication options are hard-coded in a client's configuration, we can think of their combined effect as a URI reference (<a href="##uri.references" title="URI References">Section 4.1</a>).</p></div><div id="rfc.section.7.1.p.2"><p>A URI reference is resolved to its absolute form in order to obtain the <dfn>target URI</dfn>. The target URI excludes the reference's fragment component, if any, since fragment identifiers are reserved for client-side processing (<a href="##URI" id="rfc.xref.URI.26"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[URI]</cite></a>, <a href="https://www.rfc-editor.org/rfc/rfc3986.html#section-3.5">Section 3.5</a>).</p></div><div id="rfc.section.7.1.p.3"><p>To perform an action on a <dfn>target resource</dfn>, the client sends a request message containing enough components of its parsed target URI to enable recipients to identify that same resource. For historical reasons, the parsed target URI components, collectively referred to as the <dfn>request target</dfn>, are sent within the message control data and the <a href="##field.host" class="smpl">Host</a> header field (<a href="##field.host" id="rfc.xref.field.host.2" title="Host and :authority">Section 7.2</a>).</p></div><div id="rfc.section.7.1.p.4" class="avoidbreakafter"><p>There are two unusual cases for which the request target components are in a method-specific form:</p></div><div id="rfc.section.7.1.p.5"><ul><li>For CONNECT (<a href="##CONNECT" id="rfc.xref.CONNECT.3" title="CONNECT">Section 9.3.6</a>), the request target is the host name and port number of the tunnel destination, separated by a colon.</li><li>For OPTIONS (<a href="##OPTIONS" id="rfc.xref.OPTIONS.1" title="OPTIONS">Section 9.3.7</a>), the request target can be a single asterisk ("*").</li></ul></div><div id="rfc.section.7.1.p.6"><p>See the respective method definitions for details. These forms <em class="bcp14">MUST NOT</em> be used with other methods.</p></div><div id="rfc.section.7.1.p.7"><p>Upon receipt of a client's request, a server reconstructs the target URI from the received components in accordance with their local configuration and incoming connection context. This reconstruction is specific to each major protocol version. For example, <a href="https://httpwg.org/specs/rfc9112.html#reconstructing.target.uri" title="Reconstructing the Target URI">Section 3.3</a> of <a href="##HTTP11" id="rfc.xref.HTTP11.8"><cite title="HTTP/1.1">[HTTP/1.1]</cite></a> defines how a server determines the target URI of an HTTP/1.1 request.</p></div><div id="rfc.section.7.1.p.8"><aside id="effective.request.uri"><div id="rfc.section.7.1.p.8.1"><p><span id="rfc.iref.e.1"></span><b>Note:</b> Previous specifications defined the recomposed target URI as a distinct concept, the <dfn>effective request URI</dfn>.</p></div></aside></div></section><section id="field.host"><h3 id="rfc.section.7.2"><a href="##rfc.section.7.2">7.2.</a>&nbsp;<a href="##field.host">Host and :authority</a></h3><div id="rfc.section.7.2.p.1"><p>The "Host" header field in a request provides the host and port information from the target URI, enabling the origin server to distinguish among resources while servicing requests for multiple host names.</p></div><div id="rfc.section.7.2.p.2"><p>In HTTP/2 <a href="##HTTP2" id="rfc.xref.HTTP2.3"><cite title="HTTP/2">[HTTP/2]</cite></a> and HTTP/3 <a href="##HTTP3" id="rfc.xref.HTTP3.3"><cite title="HTTP/3">[HTTP/3]</cite></a>, the Host header field is, in some cases, supplanted by the ":authority" pseudo-header field of a request's control data.</p></div><div id="rfc.section.7.2.p.3"><pre class="inline prettyprint lang-ietf_abnf prettyprinted" style=""><span id="rfc.iref.g.51"></span><span class="pln">  </span><a href="##field.host" class="smpl"><span class="typ">Host</span></a><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><a href="##uri.references" class="smpl"><span class="typ">uri-host</span></a><span class="pln"> </span><span class="pun">[</span><span class="pln"> </span><span class="str">":"</span><span class="pln"> </span><a href="##uri.references" class="smpl"><span class="typ">port</span></a><span class="pln"> </span><span class="pun">]</span><span class="pln"> </span><span class="com">; </span><a href="##uri" title="Identifiers in HTTP"><span class="com">Section 4</span></a>
</pre></div><div id="rfc.section.7.2.p.4"><p>The target URI's authority information is critical for handling a request. A user agent <em class="bcp14">MUST</em> generate a Host header field in a request unless it sends that information as an ":authority" pseudo-header field. A user agent that sends Host <em class="bcp14">SHOULD</em> send it as the first field in the header section of a request.</p></div><div id="rfc.section.7.2.p.5" class="avoidbreakafter"><p>For example, a GET request to the origin server for &lt;http://www.example.org/pub/WWW/&gt; would begin with:</p></div><div id="rfc.section.7.2.p.6"><pre class="text">GET /pub/WWW/ HTTP/1.1
Host: www.example.org
</pre></div><div id="rfc.section.7.2.p.7"><p>Since the host and port information acts as an application-level routing mechanism, it is a frequent target for malware seeking to poison a shared cache or redirect a request to an unintended server. An interception proxy is particularly vulnerable if it relies on the host and port information for redirecting requests to internal servers, or for use as a cache key in a shared cache, without first verifying that the intercepted connection is targeting a valid IP address for that host.</p></div></section><section id="routing.inbound"><h3 id="rfc.section.7.3"><a href="##rfc.section.7.3">7.3.</a>&nbsp;<a href="##routing.inbound">Routing Inbound Requests</a></h3><div id="rfc.section.7.3.p.1"><p>Once the target URI and its origin are determined, a client decides whether a network request is necessary to accomplish the desired semantics and, if so, where that request is to be directed.</p></div><section id="routing.cache"><h4 id="rfc.section.7.3.1"><a href="##rfc.section.7.3.1">7.3.1.</a>&nbsp;<a href="##routing.cache">To a Cache</a></h4><div id="rfc.section.7.3.1.p.1"><p>If the client has a cache <a href="##CACHING" id="rfc.xref.CACHING.7"><cite title="HTTP Caching">[CACHING]</cite></a> and the request can be satisfied by it, then the request is usually directed there first.</p></div></section><section id="routing.proxy"><h4 id="rfc.section.7.3.2"><a href="##rfc.section.7.3.2">7.3.2.</a>&nbsp;<a href="##routing.proxy">To a Proxy</a></h4><div id="rfc.section.7.3.2.p.1"><p>If the request is not satisfied by a cache, then a typical client will check its configuration to determine whether a proxy is to be used to satisfy the request. Proxy configuration is implementation-dependent, but is often based on URI prefix matching, selective authority matching, or both, and the proxy itself is usually identified by an "http" or "https" URI.</p></div><div id="rfc.section.7.3.2.p.2"><p>If an "http" or "https" proxy is applicable, the client connects inbound by establishing (or reusing) a connection to that proxy and then sending it an HTTP request message containing a request target that matches the client's target URI.</p></div></section><section id="routing.origin"><h4 id="rfc.section.7.3.3"><a href="##rfc.section.7.3.3">7.3.3.</a>&nbsp;<a href="##routing.origin">To the Origin</a></h4><div id="rfc.section.7.3.3.p.1"><p>If no proxy is applicable, a typical client will invoke a handler routine (specific to the target URI's scheme) to obtain access to the identified resource. How that is accomplished is dependent on the target URI scheme and defined by its associated specification.</p></div><div id="rfc.section.7.3.3.p.2"><p><a href="##http.origin" title="http Origins">Section 4.3.2</a> defines how to obtain access to an "http" resource by establishing (or reusing) an inbound connection to the identified origin server and then sending it an HTTP request message containing a request target that matches the client's target URI.</p></div><div id="rfc.section.7.3.3.p.3"><p><a href="##https.origin" title="https Origins">Section 4.3.3</a> defines how to obtain access to an "https" resource by establishing (or reusing) an inbound secured connection to an origin server that is authoritative for the identified origin and then sending it an HTTP request message containing a request target that matches the client's target URI.</p></div></section></section><section id="routing.reject"><h3 id="rfc.section.7.4"><a href="##rfc.section.7.4">7.4.</a>&nbsp;<a href="##routing.reject">Rejecting Misdirected Requests</a></h3><div id="rfc.section.7.4.p.1"><p>Once a request is received by a server and parsed sufficiently to determine its target URI, the server decides whether to process the request itself, forward the request to another server, redirect the client to a different resource, respond with an error, or drop the connection. This decision can be influenced by anything about the request or connection context, but is specifically directed at whether the server has been configured to process requests for that target URI and whether the connection context is appropriate for that request.</p></div><div id="rfc.section.7.4.p.2"><p>For example, a request might have been misdirected, deliberately or accidentally, such that the information within a received <a href="##field.host" class="smpl">Host</a> header field differs from the connection's host or port. If the connection is from a trusted gateway, such inconsistency might be expected; otherwise, it might indicate an attempt to bypass security filters, trick the server into delivering non-public content, or poison a cache. See <a href="##security.considerations" title="Security Considerations">Section 17</a> for security considerations regarding message routing.</p></div><div id="rfc.section.7.4.p.3"><p>Unless the connection is from a trusted gateway, an origin server <em class="bcp14">MUST</em> reject a request if any scheme-specific requirements for the target URI are not met. In particular, a request for an "https" resource <em class="bcp14">MUST</em> be rejected unless it has been received over a connection that has been secured via a certificate valid for that target URI's origin, as defined by <a href="##https.uri" title="https URI Scheme">Section 4.2.2</a>.</p></div><div id="rfc.section.7.4.p.4"><p>The <a href="##status.421" class="smpl">421 (Misdirected Request)</a> status code in a response indicates that the origin server has rejected the request because it appears to have been misdirected (<a href="##status.421" id="rfc.xref.status.421.1" title="421 Misdirected Request">Section 15.5.20</a>).</p></div></section><section id="response.correlation"><h3 id="rfc.section.7.5"><a href="##rfc.section.7.5">7.5.</a>&nbsp;<a href="##response.correlation">Response Correlation</a></h3><div id="rfc.section.7.5.p.1"><p>A connection might be used for multiple request/response exchanges. The mechanism used to correlate between request and response messages is version dependent; some versions of HTTP use implicit ordering of messages, while others use an explicit identifier.</p></div><div id="rfc.section.7.5.p.2"><p>All responses, regardless of the status code (including <a href="##final.interim" class="smpl">interim</a> responses) can be sent at any time after a request is received, even if the request is not yet complete. A response can complete before its corresponding request is complete (<a href="##message.framing" title="Framing and Completeness">Section 6.1</a>). Likewise, clients are not expected to wait any specific amount of time for a response. Clients (including intermediaries) might abandon a request if the response is not received within a reasonable period of time.</p></div><div id="rfc.section.7.5.p.3"><p>A client that receives a response while it is still sending the associated request <em class="bcp14">SHOULD</em> continue sending that request unless it receives an explicit indication to the contrary (see, e.g., <a href="https://httpwg.org/specs/rfc9112.html#persistent.failures" title="Failures and Timeouts">Section 9.5</a> of <a href="##HTTP11" id="rfc.xref.HTTP11.9"><cite title="HTTP/1.1">[HTTP/1.1]</cite></a> and <a href="https://www.rfc-editor.org/rfc/rfc9113.html#section-6.4">Section 6.4</a> of <a href="##HTTP2" id="rfc.xref.HTTP2.4"><cite title="HTTP/2">[HTTP/2]</cite></a>).</p></div></section><section id="message.forwarding"><h3 id="rfc.section.7.6"><a href="##rfc.section.7.6">7.6.</a>&nbsp;<a href="##message.forwarding">Message Forwarding</a></h3><div id="rfc.section.7.6.p.1"><p>As described in <a href="##intermediaries" title="Intermediaries">Section 3.7</a>, intermediaries can serve a variety of roles in the processing of HTTP requests and responses. Some intermediaries are used to improve performance or availability. Others are used for access control or to filter content. Since an HTTP stream has characteristics similar to a pipe-and-filter architecture, there are no inherent limits to the extent an intermediary can enhance (or interfere) with either direction of the stream.</p></div><div id="rfc.section.7.6.p.2"><p>Intermediaries are expected to forward messages even when protocol elements are not recognized (e.g., new methods, status codes, or field names) since that preserves extensibility for downstream recipients.</p></div><div id="rfc.section.7.6.p.3"><p>An intermediary not acting as a tunnel <em class="bcp14">MUST</em> implement the <a href="##field.connection" class="smpl">Connection</a> header field, as specified in <a href="##field.connection" id="rfc.xref.field.connection.2" title="Connection">Section 7.6.1</a>, and exclude fields from being forwarded that are only intended for the incoming connection.</p></div><div id="rfc.section.7.6.p.4"><p>An intermediary <em class="bcp14">MUST NOT</em> forward a message to itself unless it is protected from an infinite request loop. In general, an intermediary ought to recognize its own server names, including any aliases, local variations, or literal IP addresses, and respond to such requests directly.</p></div><div id="rfc.section.7.6.p.5"><p>An HTTP message can be parsed as a stream for incremental processing or forwarding downstream. However, senders and recipients cannot rely on incremental delivery of partial messages, since some implementations will buffer or delay message forwarding for the sake of network efficiency, security checks, or content transformations.</p></div><section id="field.connection"><h4 id="rfc.section.7.6.1"><a href="##rfc.section.7.6.1">7.6.1.</a>&nbsp;<a href="##field.connection">Connection</a></h4><div id="rfc.section.7.6.1.p.1"><p>The "Connection" header field allows the sender to list desired control options for the current connection.</p></div><div id="rfc.section.7.6.1.p.2"><pre class="inline prettyprint lang-ietf_abnf prettyprinted" style=""><span id="rfc.iref.g.52"></span><span id="rfc.iref.g.53"></span><span class="pln">  </span><a href="##field.connection" class="smpl"><span class="typ">Connection</span></a><span class="pln">        </span><span class="pun">=</span><span class="pln"> </span><span class="pun">#</span><a href="##field.connection" class="smpl"><span class="typ">connection-option</span></a><span class="pln">
  </span><a href="##field.connection" class="smpl"><span class="typ">connection-option</span></a><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><a href="##rule.token.separators" class="smpl"><span class="typ">token</span></a>
</pre></div><div id="rfc.section.7.6.1.p.3"><p>Connection options are case-insensitive.</p></div><div id="rfc.section.7.6.1.p.4"><p>When a field aside from Connection is used to supply control information for or about the current connection, the sender <em class="bcp14">MUST</em> list the corresponding field name within the Connection header field. Note that some versions of HTTP prohibit the use of fields for such information, and therefore do not allow the Connection field.</p></div><div id="rfc.section.7.6.1.p.5"><p>Intermediaries <em class="bcp14">MUST</em> parse a received Connection header field before a message is forwarded and, for each connection-option in this field, remove any header or trailer field(s) from the message with the same name as the connection-option, and then remove the Connection header field itself (or replace it with the intermediary's own control options for the forwarded message).</p></div><div id="rfc.section.7.6.1.p.6"><p>Hence, the Connection header field provides a declarative way of distinguishing fields that are only intended for the immediate recipient ("hop-by-hop") from those fields that are intended for all recipients on the chain ("end-to-end"), enabling the message to be self-descriptive and allowing future connection-specific extensions to be deployed without fear that they will be blindly forwarded by older intermediaries.</p></div><div id="rfc.section.7.6.1.p.7" class="avoidbreakafter"><p>Furthermore, intermediaries <em class="bcp14">SHOULD</em> remove or replace fields that are known to require removal before forwarding, whether or not they appear as a connection-option, after applying those fields' semantics. This includes but is not limited to:</p></div><div id="rfc.section.7.6.1.p.8"><ul><li>Proxy-Connection (<a href="https://httpwg.org/specs/rfc9112.html#compatibility.with.http.1.0.persistent.connections" title="Keep-Alive Connections">Appendix C.2.2</a> of <a href="##HTTP11" id="rfc.xref.HTTP11.10"><cite title="HTTP/1.1">[HTTP/1.1]</cite></a>)</li><li>Keep-Alive (<a href="https://www.rfc-editor.org/rfc/rfc2068.html#section-19.7.1">Section 19.7.1</a> of <a href="##RFC2068" id="rfc.xref.RFC2068.2"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2068]</cite></a>)</li><li>TE (<a href="##field.te" id="rfc.xref.field.te.2" title="TE">Section 10.1.4</a>)</li><li>Transfer-Encoding (<a href="https://httpwg.org/specs/rfc9112.html#field.transfer-encoding" title="Transfer-Encoding">Section 6.1</a> of <a href="##HTTP11" id="rfc.xref.HTTP11.11"><cite title="HTTP/1.1">[HTTP/1.1]</cite></a>)</li><li>Upgrade (<a href="##field.upgrade" id="rfc.xref.field.upgrade.2" title="Upgrade">Section 7.8</a>)</li></ul></div><div id="rfc.section.7.6.1.p.9"><p>A sender <em class="bcp14">MUST NOT</em> send a connection option corresponding to a field that is intended for all recipients of the content. For example, <a href="https://httpwg.org/specs/rfc9111.html#field.cache-control" class="smpl">Cache-Control</a> is never appropriate as a connection option (<a href="https://httpwg.org/specs/rfc9111.html#field.cache-control" title="Cache-Control">Section 5.2</a> of <a href="##CACHING" id="rfc.xref.CACHING.8"><cite title="HTTP Caching">[CACHING]</cite></a>).</p></div><div id="rfc.section.7.6.1.p.10"><p>Connection options do not always correspond to a field present in the message, since a connection-specific field might not be needed if there are no parameters associated with a connection option. In contrast, a connection-specific field received without a corresponding connection option usually indicates that the field has been improperly forwarded by an intermediary and ought to be ignored by the recipient.</p></div><div id="rfc.section.7.6.1.p.11"><p>When defining a new connection option that does not correspond to a field, specification authors ought to reserve the corresponding field name anyway in order to avoid later collisions. Such reserved field names are registered in the "Hypertext Transfer Protocol (HTTP) Field Name Registry" (<a href="##fields.registry" title="Field Name Registry">Section 16.3.1</a>).</p></div></section><section id="field.max-forwards"><h4 id="rfc.section.7.6.2"><a href="##rfc.section.7.6.2">7.6.2.</a>&nbsp;<a href="##field.max-forwards">Max-Forwards</a></h4><div id="rfc.section.7.6.2.p.1"><p>The "Max-Forwards" header field provides a mechanism with the TRACE (<a href="##TRACE" id="rfc.xref.TRACE.1" title="TRACE">Section 9.3.8</a>) and OPTIONS (<a href="##OPTIONS" id="rfc.xref.OPTIONS.2" title="OPTIONS">Section 9.3.7</a>) request methods to limit the number of times that the request is forwarded by proxies. This can be useful when the client is attempting to trace a request that appears to be failing or looping mid-chain.</p></div><div id="rfc.section.7.6.2.p.2"><pre class="inline prettyprint lang-ietf_abnf prettyprinted" style=""><span id="rfc.iref.g.54"></span><span class="pln">  </span><a href="##field.max-forwards" class="smpl"><span class="typ">Max-Forwards</span></a><span class="pln"> </span><span class="pun">=</span><span class="pln"> 1</span><span class="pun">*</span><a href="##core.rules" class="smpl"><span class="typ">DIGIT</span></a>
</pre></div><div id="rfc.section.7.6.2.p.3"><p>The Max-Forwards value is a decimal integer indicating the remaining number of times this request message can be forwarded.</p></div><div id="rfc.section.7.6.2.p.4"><p>Each intermediary that receives a TRACE or OPTIONS request containing a Max-Forwards header field <em class="bcp14">MUST</em> check and update its value prior to forwarding the request. If the received value is zero (0), the intermediary <em class="bcp14">MUST NOT</em> forward the request; instead, the intermediary <em class="bcp14">MUST</em> respond as the final recipient. If the received Max-Forwards value is greater than zero, the intermediary <em class="bcp14">MUST</em> generate an updated Max-Forwards field in the forwarded message with a field value that is the lesser of a) the received value decremented by one (1) or b) the recipient's maximum supported value for Max-Forwards.</p></div><div id="rfc.section.7.6.2.p.5"><p>A recipient <em class="bcp14">MAY</em> ignore a Max-Forwards header field received with any other request methods.</p></div></section><section id="field.via"><h4 id="rfc.section.7.6.3"><a href="##rfc.section.7.6.3">7.6.3.</a>&nbsp;<a href="##field.via">Via</a></h4><div id="rfc.section.7.6.3.p.1"><p>The "Via" header field indicates the presence of intermediate protocols and recipients between the user agent and the server (on requests) or between the origin server and the client (on responses), similar to the "Received" header field in email (<a href="https://www.rfc-editor.org/rfc/rfc5322.html#section-3.6.7">Section 3.6.7</a> of <a href="##RFC5322" id="rfc.xref.RFC5322.5"><cite title="Internet Message Format">[RFC5322]</cite></a>). Via can be used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities of senders along the request/response chain.</p></div><div id="rfc.section.7.6.3.p.2"><pre class="inline prettyprint lang-ietf_abnf prettyprinted" style=""><span id="rfc.iref.g.55"></span><span id="rfc.iref.g.56"></span><span id="rfc.iref.g.57"></span><span id="rfc.iref.g.58"></span><span id="rfc.iref.g.59"></span><span id="rfc.iref.g.60"></span><span class="pln">  </span><a href="##field.via" class="smpl"><span class="typ">Via</span></a><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">#(</span><span class="pln"> </span><a href="##field.via" class="smpl"><span class="typ">received-protocol</span></a><span class="pln"> </span><a href="##whitespace" class="smpl"><span class="typ">RWS</span></a><span class="pln"> </span><a href="##field.via" class="smpl"><span class="typ">received-by</span></a><span class="pln"> </span><span class="pun">[</span><span class="pln"> </span><a href="##whitespace" class="smpl"><span class="typ">RWS</span></a><span class="pln"> </span><a href="##rule.comment" class="smpl"><span class="typ">comment</span></a><span class="pln"> </span><span class="pun">]</span><span class="pln"> </span><span class="pun">)</span><span class="pln">

  </span><a href="##field.via" class="smpl"><span class="typ">received-protocol</span></a><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="pln"> </span><a href="##field.upgrade" class="smpl"><span class="typ">protocol-name</span></a><span class="pln"> </span><span class="str">"/"</span><span class="pln"> </span><span class="pun">]</span><span class="pln"> </span><a href="##field.upgrade" class="smpl"><span class="typ">protocol-version</span></a><span class="pln">
                    </span><span class="com">; see </span><a href="##field.upgrade" id="rfc.xref.field.upgrade.3" title="Upgrade"><span class="com">Section 7.8</span></a><span class="pln">
  </span><a href="##field.via" class="smpl"><span class="typ">received-by</span></a><span class="pln">       </span><span class="pun">=</span><span class="pln"> </span><a href="##field.via" class="smpl"><span class="typ">pseudonym</span></a><span class="pln"> </span><span class="pun">[</span><span class="pln"> </span><span class="str">":"</span><span class="pln"> </span><a href="##uri.references" class="smpl"><span class="typ">port</span></a><span class="pln"> </span><span class="pun">]</span><span class="pln">
  </span><a href="##field.via" class="smpl"><span class="typ">pseudonym</span></a><span class="pln">         </span><span class="pun">=</span><span class="pln"> </span><a href="##rule.token.separators" class="smpl"><span class="typ">token</span></a>
</pre></div><div id="rfc.section.7.6.3.p.3"><p>Each member of the Via field value represents a proxy or gateway that has forwarded the message. Each intermediary appends its own information about how the message was received, such that the end result is ordered according to the sequence of forwarding recipients.</p></div><div id="rfc.section.7.6.3.p.4"><p>A proxy <em class="bcp14">MUST</em> send an appropriate Via header field, as described below, in each message that it forwards. An HTTP-to-HTTP gateway <em class="bcp14">MUST</em> send an appropriate Via header field in each inbound request message and <em class="bcp14">MAY</em> send a Via header field in forwarded response messages.</p></div><div id="rfc.section.7.6.3.p.5"><p>For each intermediary, the received-protocol indicates the protocol and protocol version used by the upstream sender of the message. Hence, the Via field value records the advertised protocol capabilities of the request/response chain such that they remain visible to downstream recipients; this can be useful for determining what backwards-incompatible features might be safe to use in response, or within a later request, as described in <a href="##protocol.version" title="Protocol Version">Section 2.5</a>. For brevity, the protocol-name is omitted when the received protocol is HTTP.</p></div><div id="rfc.section.7.6.3.p.6"><p>The received-by portion is normally the host and optional port number of a recipient server or client that subsequently forwarded the message. However, if the real host is considered to be sensitive information, a sender <em class="bcp14">MAY</em> replace it with a pseudonym. If a port is not provided, a recipient <em class="bcp14">MAY</em> interpret that as meaning it was received on the default port, if any, for the received-protocol.</p></div><div id="rfc.section.7.6.3.p.7"><p>A sender <em class="bcp14">MAY</em> generate comments to identify the software of each recipient, analogous to the <a href="##field.user-agent" class="smpl">User-Agent</a> and <a href="##field.server" class="smpl">Server</a> header fields. However, comments in Via are optional, and a recipient <em class="bcp14">MAY</em> remove them prior to forwarding the message.</p></div><div id="rfc.section.7.6.3.p.8" class="avoidbreakafter"><p>For example, a request message could be sent from an HTTP/1.0 user agent to an internal proxy code-named "fred", which uses HTTP/1.1 to forward the request to a public proxy at p.example.net, which completes the request by forwarding it to the origin server at www.example.com. The request received by www.example.com would then have the following Via header field:</p></div><div id="rfc.section.7.6.3.p.9"><pre class="text">Via: 1.0 fred, 1.1 p.example.net
</pre></div><div id="rfc.section.7.6.3.p.10"><p>An intermediary used as a portal through a network firewall <em class="bcp14">SHOULD NOT</em> forward the names and ports of hosts within the firewall region unless it is explicitly enabled to do so. If not enabled, such an intermediary <em class="bcp14">SHOULD</em> replace each received-by host of any host behind the firewall by an appropriate pseudonym for that host.</p></div><div id="rfc.section.7.6.3.p.11"><p>An intermediary <em class="bcp14">MAY</em> combine an ordered subsequence of Via header field list members into a single member if the entries have identical received-protocol values. For example,</p></div><div id="rfc.section.7.6.3.p.12"><pre class="text">Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy
</pre></div><div id="rfc.section.7.6.3.p.13"><p>could be collapsed to</p></div><div id="rfc.section.7.6.3.p.14"><pre class="text">Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
</pre></div><div id="rfc.section.7.6.3.p.15"><p>A sender <em class="bcp14">SHOULD NOT</em> combine multiple list members unless they are all under the same organizational control and the hosts have already been replaced by pseudonyms. A sender <em class="bcp14">MUST NOT</em> combine members that have different received-protocol values.</p></div></section></section><section id="message.transformations"><h3 id="rfc.section.7.7"><a href="##rfc.section.7.7">7.7.</a>&nbsp;<a href="##message.transformations">Message Transformations</a></h3><div id="rfc.section.7.7.p.1"><p>Some intermediaries include features for transforming messages and their content. A proxy might, for example, convert between image formats in order to save cache space or to reduce the amount of traffic on a slow link. However, operational problems might occur when these transformations are applied to content intended for critical applications, such as medical imaging or scientific data analysis, particularly when integrity checks or digital signatures are used to ensure that the content received is identical to the original.</p></div><div id="rfc.section.7.7.p.2"><p>An HTTP-to-HTTP proxy is called a <dfn>transforming proxy</dfn> if it is designed or configured to modify messages in a semantically meaningful way (i.e., modifications, beyond those required by normal HTTP processing, that change the message in a way that would be significant to the original sender or potentially significant to downstream recipients). For example, a transforming proxy might be acting as a shared annotation server (modifying responses to include references to a local annotation database), a malware filter, a format transcoder, or a privacy filter. Such transformations are presumed to be desired by whichever client (or client organization) chose the proxy.</p></div><div id="rfc.section.7.7.p.3"><p>If a proxy receives a target URI with a host name that is not a fully qualified domain name, it <em class="bcp14">MAY</em> add its own domain to the host name it received when forwarding the request. A proxy <em class="bcp14">MUST NOT</em> change the host name if the target URI contains a fully qualified domain name.</p></div><div id="rfc.section.7.7.p.4"><p>A proxy <em class="bcp14">MUST NOT</em> modify the "absolute-path" and "query" parts of the received target URI when forwarding it to the next inbound server except as required by that forwarding protocol. For example, a proxy forwarding a request to an origin server via HTTP/1.1 will replace an empty path with "/" (<a href="https://httpwg.org/specs/rfc9112.html#origin-form" title="origin-form">Section 3.2.1</a> of <a href="##HTTP11" id="rfc.xref.HTTP11.12"><cite title="HTTP/1.1">[HTTP/1.1]</cite></a>) or "*" (<a href="https://httpwg.org/specs/rfc9112.html#asterisk-form" title="asterisk-form">Section 3.2.4</a> of <a href="##HTTP11" id="rfc.xref.HTTP11.13"><cite title="HTTP/1.1">[HTTP/1.1]</cite></a>), depending on the request method.</p></div><div id="rfc.section.7.7.p.5"><p>A proxy <em class="bcp14">MUST NOT</em> transform the content (<a href="##content" title="Content">Section 6.4</a>) of a response message that contains a no-transform cache directive (<a href="https://httpwg.org/specs/rfc9111.html#cache-response-directive.no-transform" title="no-transform">Section 5.2.2.6</a> of <a href="##CACHING" id="rfc.xref.CACHING.9"><cite title="HTTP Caching">[CACHING]</cite></a>). Note that this does not apply to message transformations that do not change the content, such as the addition or removal of transfer codings (<a href="https://httpwg.org/specs/rfc9112.html#transfer.codings" title="Transfer Codings">Section 7</a> of <a href="##HTTP11" id="rfc.xref.HTTP11.14"><cite title="HTTP/1.1">[HTTP/1.1]</cite></a>).</p></div><div id="rfc.section.7.7.p.6"><p>A proxy <em class="bcp14">MAY</em> transform the content of a message that does not contain a no-transform cache directive. A proxy that transforms the content of a <a href="##status.200" class="smpl">200 (OK)</a> response can inform downstream recipients that a transformation has been applied by changing the response status code to <a href="##status.203" class="smpl">203 (Non-Authoritative Information)</a> (<a href="##status.203" id="rfc.xref.status.203.1" title="203 Non-Authoritative Information">Section 15.3.4</a>).</p></div><div id="rfc.section.7.7.p.7"><p>A proxy <em class="bcp14">SHOULD NOT</em> modify header fields that provide information about the endpoints of the communication chain, the resource state, or the <a href="##selected.representation" class="smpl">selected representation</a> (other than the content) unless the field's definition specifically allows such modification or the modification is deemed necessary for privacy or security.</p></div></section><section id="field.upgrade"><h3 id="rfc.section.7.8"><a href="##rfc.section.7.8">7.8.</a>&nbsp;<a href="##field.upgrade">Upgrade</a></h3><div id="rfc.section.7.8.p.1"><p>The "Upgrade" header field is intended to provide a simple mechanism for transitioning from HTTP/1.1 to some other protocol on the same connection.</p></div><div id="rfc.section.7.8.p.2"><p>A client <em class="bcp14">MAY</em> send a list of protocol names in the Upgrade header field of a request to invite the server to switch to one or more of the named protocols, in order of descending preference, before sending the final response. A server <em class="bcp14">MAY</em> ignore a received Upgrade header field if it wishes to continue using the current protocol on that connection. Upgrade cannot be used to insist on a protocol change.</p></div><div id="rfc.section.7.8.p.3"><pre class="inline prettyprint lang-ietf_abnf prettyprinted" style=""><span id="rfc.iref.g.61"></span><span class="pln">  </span><a href="##field.upgrade" class="smpl"><span class="typ">Upgrade</span></a><span class="pln">          </span><span class="pun">=</span><span class="pln"> </span><span class="pun">#</span><a href="##field.upgrade" class="smpl"><span class="typ">protocol</span></a><span class="pln">

  </span><a href="##field.upgrade" class="smpl"><span class="typ">protocol</span></a><span class="pln">         </span><span class="pun">=</span><span class="pln"> </span><a href="##field.upgrade" class="smpl"><span class="typ">protocol-name</span></a><span class="pln"> </span><span class="pun">[</span><span class="str">"/"</span><span class="pln"> </span><a href="##field.upgrade" class="smpl"><span class="typ">protocol-version</span></a><span class="pun">]</span><span class="pln">
  </span><a href="##field.upgrade" class="smpl"><span class="typ">protocol-name</span></a><span class="pln">    </span><span class="pun">=</span><span class="pln"> </span><a href="##rule.token.separators" class="smpl"><span class="typ">token</span></a><span class="pln">
  </span><a href="##field.upgrade" class="smpl"><span class="typ">protocol-version</span></a><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><a href="##rule.token.separators" class="smpl"><span class="typ">token</span></a>
</pre></div><div id="rfc.section.7.8.p.4"><p>Although protocol names are registered with a preferred case, recipients <em class="bcp14">SHOULD</em> use case-insensitive comparison when matching each protocol-name to supported protocols.</p></div><div id="rfc.section.7.8.p.5"><p>A server that sends a <a href="##status.101" class="smpl">101 (Switching Protocols)</a> response <em class="bcp14">MUST</em> send an Upgrade header field to indicate the new protocol(s) to which the connection is being switched; if multiple protocol layers are being switched, the sender <em class="bcp14">MUST</em> list the protocols in layer-ascending order. A server <em class="bcp14">MUST NOT</em> switch to a protocol that was not indicated by the client in the corresponding request's Upgrade header field. A server <em class="bcp14">MAY</em> choose to ignore the order of preference indicated by the client and select the new protocol(s) based on other factors, such as the nature of the request or the current load on the server.</p></div><div id="rfc.section.7.8.p.6"><p>A server that sends a <a href="##status.426" class="smpl">426 (Upgrade Required)</a> response <em class="bcp14">MUST</em> send an Upgrade header field to indicate the acceptable protocols, in order of descending preference.</p></div><div id="rfc.section.7.8.p.7"><p>A server <em class="bcp14">MAY</em> send an Upgrade header field in any other response to advertise that it implements support for upgrading to the listed protocols, in order of descending preference, when appropriate for a future request.</p></div><div id="rfc.section.7.8.p.8" class="avoidbreakafter"><p>The following is a hypothetical example sent by a client:</p></div><div id="rfc.section.7.8.p.9"><pre class="text">GET /hello HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: websocket, IRC/6.9, RTA/x11

</pre></div><div id="rfc.section.7.8.p.10"><p>The capabilities and nature of the application-level communication after the protocol change is entirely dependent upon the new protocol(s) chosen. However, immediately after sending the <a href="##status.101" class="smpl">101 (Switching Protocols)</a> response, the server is expected to continue responding to the original request as if it had received its equivalent within the new protocol (i.e., the server still has an outstanding request to satisfy after the protocol has been changed, and is expected to do so without requiring the request to be repeated).</p></div><div id="rfc.section.7.8.p.11"><p>For example, if the Upgrade header field is received in a GET request and the server decides to switch protocols, it first responds with a <a href="##status.101" class="smpl">101 (Switching Protocols)</a> message in HTTP/1.1 and then immediately follows that with the new protocol's equivalent of a response to a GET on the target resource. This allows a connection to be upgraded to protocols with the same semantics as HTTP without the latency cost of an additional round trip. A server <em class="bcp14">MUST NOT</em> switch protocols unless the received message semantics can be honored by the new protocol; an OPTIONS request can be honored by any protocol.</p></div><div id="rfc.section.7.8.p.12" class="avoidbreakafter"><p>The following is an example response to the above hypothetical request:</p></div><div id="rfc.section.7.8.p.13"><pre class="text">HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: websocket

[... data stream switches to websocket with an appropriate response
(as defined by new protocol) to the "GET /hello" request ...]
</pre></div><div id="rfc.section.7.8.p.14"><p>A sender of Upgrade <em class="bcp14">MUST</em> also send an "Upgrade" connection option in the <a href="##field.connection" class="smpl">Connection</a> header field (<a href="##field.connection" id="rfc.xref.field.connection.3" title="Connection">Section 7.6.1</a>) to inform intermediaries not to forward this field. A server that receives an Upgrade header field in an HTTP/1.0 request <em class="bcp14">MUST</em> ignore that Upgrade field.</p></div><div id="rfc.section.7.8.p.15"><p>A client cannot begin using an upgraded protocol on the connection until it has completely sent the request message (i.e., the client can't change the protocol it is sending in the middle of a message). If a server receives both an Upgrade and an <a href="##field.expect" class="smpl">Expect</a> header field with the "100-continue" expectation (<a href="##field.expect" id="rfc.xref.field.expect.1" title="Expect">Section 10.1.1</a>), the server <em class="bcp14">MUST</em> send a <a href="##status.100" class="smpl">100 (Continue)</a> response before sending a <a href="##status.101" class="smpl">101 (Switching Protocols)</a> response.</p></div><div id="rfc.section.7.8.p.16"><p>The Upgrade header field only applies to switching protocols on top of the existing connection; it cannot be used to switch the underlying connection (transport) protocol, nor to switch the existing communication to a different connection. For those purposes, it is more appropriate to use a <a href="##status.3xx" class="smpl">3xx (Redirection)</a> response (<a href="##status.3xx" id="rfc.xref.status.3xx.1" title="Redirection 3xx">Section 15.4</a>).</p></div><div id="rfc.section.7.8.p.17"><p>This specification only defines the protocol name "HTTP" for use by the family of Hypertext Transfer Protocols, as defined by the HTTP version rules of <a href="##protocol.version" title="Protocol Version">Section 2.5</a> and future updates to this specification. Additional protocol names ought to be registered using the registration procedure defined in <a href="##upgrade.token.registry" title="Upgrade Token Registry">Section 16.7</a>.</p></div></section></section><section id="representation.data.and.metadata"><h2 id="rfc.section.8"><a href="##rfc.section.8">8.</a>&nbsp;<a href="##representation.data.and.metadata">Representation Data and Metadata</a></h2><section id="representation.data"><h3 id="rfc.section.8.1"><a href="##rfc.section.8.1">8.1.</a>&nbsp;<a href="##representation.data">Representation Data</a></h3><div id="rfc.section.8.1.p.1"><p>The representation data associated with an HTTP message is either provided as the content of the message or referred to by the message semantics and the target URI. The representation data is in a format and encoding defined by the representation metadata header fields.</p></div><div id="rfc.section.8.1.p.2" class="avoidbreakafter"><p>The data type of the representation data is determined via the header fields <a href="##field.content-type" class="smpl">Content-Type</a> and <a href="##field.content-encoding" class="smpl">Content-Encoding</a>. These define a two-layer, ordered encoding model:</p></div><div id="rfc.section.8.1.p.3"><pre class="text">  representation-data := Content-Encoding( Content-Type( data ) )
</pre></div></section><section id="representation.metadata"><h3 id="rfc.section.8.2"><a href="##rfc.section.8.2">8.2.</a>&nbsp;<a href="##representation.metadata">Representation Metadata</a></h3><div id="rfc.section.8.2.p.1"><p>Representation header fields provide metadata about the representation. When a message includes content, the representation header fields describe how to interpret that data. In a response to a HEAD request, the representation header fields describe the representation data that would have been enclosed in the content if the same request had been a GET.</p></div></section><section id="field.content-type"><h3 id="rfc.section.8.3"><a href="##rfc.section.8.3">8.3.</a>&nbsp;<a href="##field.content-type">Content-Type</a></h3><div id="rfc.section.8.3.p.1"><p>The "Content-Type" header field indicates the media type of the associated representation: either the representation enclosed in the message content or the <a href="##selected.representation" class="smpl">selected representation</a>, as determined by the message semantics. The indicated media type defines both the data format and how that data is intended to be processed by a recipient, within the scope of the received message semantics, after any content codings indicated by <a href="##field.content-encoding" class="smpl">Content-Encoding</a> are decoded.</p></div><div id="rfc.section.8.3.p.2"><pre class="inline prettyprint lang-ietf_abnf prettyprinted" style=""><span id="rfc.iref.g.62"></span><span class="pln">  </span><a href="##field.content-type" class="smpl"><span class="typ">Content-Type</span></a><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><a href="##media.type" class="smpl"><span class="typ">media-type</span></a>
</pre></div><div id="rfc.section.8.3.p.3"><p>Media types are defined in <a href="##media.type" title="Media Type">Section 8.3.1</a>. An example of the field is</p></div><div id="rfc.section.8.3.p.4"><pre class="text">Content-Type: text/html; charset=ISO-8859-4
</pre></div><div id="rfc.section.8.3.p.5"><p>A sender that generates a message containing content <em class="bcp14">SHOULD</em> generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender. If a Content-Type header field is not present, the recipient <em class="bcp14">MAY</em> either assume a media type of "application/octet-stream" (<a href="##RFC2046" id="rfc.xref.RFC2046.1"><cite title="Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types">[RFC2046]</cite></a>, <a href="https://www.rfc-editor.org/rfc/rfc2046.html#section-4.5.1">Section 4.5.1</a>) or examine the data to determine its type.</p></div><div id="rfc.section.8.3.p.6"><p>In practice, resource owners do not always properly configure their origin server to provide the correct Content-Type for a given representation. Some user agents examine the content and, in certain cases, override the received type (for example, see <a href="##Sniffing" id="rfc.xref.Sniffing.1"><cite title="MIME Sniffing">[Sniffing]</cite></a>). This "MIME sniffing" risks drawing incorrect conclusions about the data, which might expose the user to additional security risks (e.g., "privilege escalation"). Furthermore, distinct media types often share a common data format, differing only in how the data is intended to be processed, which is impossible to distinguish by inspecting the data alone. When sniffing is implemented, implementers are encouraged to provide a means for the user to disable it.</p></div><div id="rfc.section.8.3.p.7"><p>Although Content-Type is defined as a singleton field, it is sometimes incorrectly generated multiple times, resulting in a combined field value that appears to be a list. Recipients often attempt to handle this error by using the last syntactically valid member of the list, leading to potential interoperability and security issues if different implementations have different error handling behaviors.</p></div><section id="media.type"><h4 id="rfc.section.8.3.1"><a href="##rfc.section.8.3.1">8.3.1.</a>&nbsp;<a href="##media.type">Media Type</a></h4><div id="rfc.section.8.3.1.p.1"><p>HTTP uses media types <a href="##RFC2046" id="rfc.xref.RFC2046.2"><cite title="Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types">[RFC2046]</cite></a> in the <a href="##field.content-type" class="smpl">Content-Type</a> (<a href="##field.content-type" id="rfc.xref.field.content-type.2" title="Content-Type">Section 8.3</a>) and <a href="##field.accept" class="smpl">Accept</a> (<a href="##field.accept" id="rfc.xref.field.accept.2" title="Accept">Section 12.5.1</a>) header fields in order to provide open and extensible data typing and type negotiation. Media types define both a data format and various processing models: how to process that data in accordance with the message context.</p></div><div id="rfc.section.8.3.1.p.2"><pre class="inline prettyprint lang-ietf_abnf prettyprinted" style=""><span id="rfc.iref.g.63"></span><span id="rfc.iref.g.64"></span><span id="rfc.iref.g.65"></span><span class="pln">  </span><a href="##media.type" class="smpl"><span class="typ">media-type</span></a><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><a href="##media.type" class="smpl"><span class="typ">type</span></a><span class="pln"> </span><span class="str">"/"</span><span class="pln"> </span><a href="##media.type" class="smpl"><span class="typ">subtype</span></a><span class="pln"> </span><a href="##rule.parameter" class="smpl"><span class="typ">parameters</span></a><span class="pln">
  </span><a href="##media.type" class="smpl"><span class="typ">type</span></a><span class="pln">       </span><span class="pun">=</span><span class="pln"> </span><a href="##rule.token.separators" class="smpl"><span class="typ">token</span></a><span class="pln">
  </span><a href="##media.type" class="smpl"><span class="typ">subtype</span></a><span class="pln">    </span><span class="pun">=</span><span class="pln"> </span><a href="##rule.token.separators" class="smpl"><span class="typ">token</span></a>
</pre></div><div id="rfc.section.8.3.1.p.3"><p>The type and subtype tokens are case-insensitive.</p></div><div id="rfc.section.8.3.1.p.4"><p>The type/subtype <em class="bcp14">MAY</em> be followed by semicolon-delimited parameters (<a href="##parameter" title="Parameters">Section 5.6.6</a>) in the form of name/value pairs. The presence or absence of a parameter might be significant to the processing of a media type, depending on its definition within the media type registry. Parameter values might or might not be case-sensitive, depending on the semantics of the parameter name.</p></div><div id="rfc.section.8.3.1.p.5" class="avoidbreakafter"><p>For example, the following media types are equivalent in describing HTML text data encoded in the UTF-8 character encoding scheme, but the first is preferred for consistency (the "charset" parameter value is defined as being case-insensitive in <a href="##RFC2046" id="rfc.xref.RFC2046.3"><cite title="Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types">[RFC2046]</cite></a>, <a href="https://www.rfc-editor.org/rfc/rfc2046.html#section-4.1.2">Section 4.1.2</a>):</p></div><div id="rfc.section.8.3.1.p.6"><pre class="text">  text/html;charset=utf-8
  Text/HTML;Charset="utf-8"
  text/html; charset="utf-8"
  text/html;charset=UTF-8
</pre></div><div id="rfc.section.8.3.1.p.7"><p>Media types ought to be registered with IANA according to the procedures defined in <a href="##BCP13" id="rfc.xref.BCP13.1">[BCP13]</a>.</p></div></section><section id="charset"><h4 id="rfc.section.8.3.2"><a href="##rfc.section.8.3.2">8.3.2.</a>&nbsp;<a href="##charset">Charset</a></h4><div id="rfc.section.8.3.2.p.1"><p>HTTP uses <dfn>charset</dfn> names to indicate or negotiate the character encoding scheme (<a href="##RFC6365" id="rfc.xref.RFC6365.2"><cite title="Terminology Used in Internationalization in the IETF">[RFC6365]</cite></a>, <a href="https://www.rfc-editor.org/rfc/rfc6365.html#section-2">Section 2</a>) of a textual representation. In the fields defined by this document, charset names appear either in parameters (<a href="##field.content-type" class="smpl">Content-Type</a>), or, for <a href="##field.accept-encoding" class="smpl">Accept-Encoding</a>, in the form of a plain <a href="##rule.token.separators" class="smpl">token</a>. In both cases, charset names are matched case-insensitively.</p></div><div id="rfc.section.8.3.2.p.2"><p>Charset names ought to be registered in the IANA "Character Sets" registry (<a href="https://www.iana.org/assignments/character-sets">https://www.iana.org/assignments/character-sets</a>) according to the procedures defined in <a href="https://www.rfc-editor.org/rfc/rfc2978.html#section-2">Section 2</a> of <a href="##RFC2978" id="rfc.xref.RFC2978.1"><cite title="IANA Charset Registration Procedures">[RFC2978]</cite></a>.</p></div><div id="rfc.section.8.3.2.p.3"><aside><div id="rfc.section.8.3.2.p.3.1"><p><b>Note:</b> In theory, charset names are defined by the "mime-charset" ABNF rule defined in <a href="https://www.rfc-editor.org/rfc/rfc2978.html#section-2.3">Section 2.3</a> of <a href="##RFC2978" id="rfc.xref.RFC2978.2"><cite title="IANA Charset Registration Procedures">[RFC2978]</cite></a> (as corrected in <a href="##Err1912" id="rfc.xref.Err1912.1"><cite title="Erratum ID 1912">[Err1912]</cite></a>). That rule allows two characters that are not included in "token" ("{" and "}"), but no charset name registered at the time of this writing includes braces (see <a href="##Err5433" id="rfc.xref.Err5433.1"><cite title="Erratum ID 5433">[Err5433]</cite></a>).</p></div></aside></div></section><section id="multipart.types"><h4 id="rfc.section.8.3.3"><a href="##rfc.section.8.3.3">8.3.3.</a>&nbsp;<a href="##multipart.types">Multipart Types</a></h4><div id="rfc.section.8.3.3.p.1"><p>MIME provides for a number of "multipart" types  encapsulations of one or more representations within a single message body. All multipart types share a common syntax, as defined in <a href="https://www.rfc-editor.org/rfc/rfc2046.html#section-5.1.1">Section 5.1.1</a> of <a href="##RFC2046" id="rfc.xref.RFC2046.4"><cite title="Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types">[RFC2046]</cite></a>, and include a boundary parameter as part of the media type value. The message body is itself a protocol element; a sender <em class="bcp14">MUST</em> generate only CRLF to represent line breaks between body parts.</p></div><div id="rfc.section.8.3.3.p.2"><p>HTTP message framing does not use the multipart boundary as an indicator of message body length, though it might be used by implementations that generate or process the content. For example, the "multipart/form-data" type is often used for carrying form data in a request, as described in <a href="##RFC7578" id="rfc.xref.RFC7578.1"><cite title="Returning Values from Forms: multipart/form-data">[RFC7578]</cite></a>, and the "multipart/byteranges" type is defined by this specification for use in some <a href="##status.206" class="smpl">206 (Partial Content)</a> responses (see <a href="##status.206" id="rfc.xref.status.206.2" title="206 Partial Content">Section 15.3.7</a>).</p></div></section></section><section id="field.content-encoding"><h3 id="rfc.section.8.4"><a href="##rfc.section.8.4">8.4.</a>&nbsp;<a href="##field.content-encoding">Content-Encoding</a></h3><div id="rfc.section.8.4.p.1"><p>The "Content-Encoding" header field indicates what content codings have been applied to the representation, beyond those inherent in the media type, and thus what decoding mechanisms have to be applied in order to obtain data in the media type referenced by the <a href="##field.content-type" class="smpl">Content-Type</a> header field. Content-Encoding is primarily used to allow a representation's data to be compressed without losing the identity of its underlying media type.</p></div><div id="rfc.section.8.4.p.2"><pre class="inline prettyprint lang-ietf_abnf prettyprinted" style=""><span id="rfc.iref.g.66"></span><span class="pln">  </span><a href="##field.content-encoding" class="smpl"><span class="typ">Content-Encoding</span></a><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">#</span><a href="##content.codings" class="smpl"><span class="typ">content-coding</span></a>
</pre></div><div id="rfc.section.8.4.p.3"><p>An example of its use is</p></div><div id="rfc.section.8.4.p.4"><pre class="text">Content-Encoding: gzip
</pre></div><div id="rfc.section.8.4.p.5"><p>If one or more encodings have been applied to a representation, the sender that applied the encodings <em class="bcp14">MUST</em> generate a Content-Encoding header field that lists the content codings in the order in which they were applied. Note that the coding named "identity" is reserved for its special role in <a href="##field.accept-encoding" class="smpl">Accept-Encoding</a> and thus <em class="bcp14">SHOULD NOT</em> be included.</p></div><div id="rfc.section.8.4.p.6"><p>Additional information about the encoding parameters can be provided by other header fields not defined by this specification.</p></div><div id="rfc.section.8.4.p.7"><p>Unlike Transfer-Encoding (<a href="https://httpwg.org/specs/rfc9112.html#field.transfer-encoding" title="Transfer-Encoding">Section 6.1</a> of <a href="##HTTP11" id="rfc.xref.HTTP11.15"><cite title="HTTP/1.1">[HTTP/1.1]</cite></a>), the codings listed in Content-Encoding are a characteristic of the representation; the representation is defined in terms of the coded form, and all other metadata about the representation is about the coded form unless otherwise noted in the metadata definition. Typically, the representation is only decoded just prior to rendering or analogous usage.</p></div><div id="rfc.section.8.4.p.8"><p>If the media type includes an inherent encoding, such as a data format that is always compressed, then that encoding would not be restated in Content-Encoding even if it happens to be the same algorithm as one of the content codings. Such a content coding would only be listed if, for some bizarre reason, it is applied a second time to form the representation. Likewise, an origin server might choose to publish the same data as multiple representations that differ only in whether the coding is defined as part of <a href="##field.content-type" class="smpl">Content-Type</a> or Content-Encoding, since some user agents will behave differently in their handling of each response (e.g., open a "Save as ..." dialog instead of automatic decompression and rendering of content).</p></div><div id="rfc.section.8.4.p.9"><p>An origin server <em class="bcp14">MAY</em> respond with a status code of <a href="##status.415" class="smpl">415 (Unsupported Media Type)</a> if a representation in the request message has a content coding that is not acceptable.</p></div><section id="content.codings"><h4 id="rfc.section.8.4.1"><a href="##rfc.section.8.4.1">8.4.1.</a>&nbsp;<a href="##content.codings">Content Codings</a></h4><div id="rfc.section.8.4.1.p.1"><p>Content coding values indicate an encoding transformation that has been or can be applied to a representation. Content codings are primarily used to allow a representation to be compressed or otherwise usefully transformed without losing the identity of its underlying media type and without loss of information. Frequently, the representation is stored in coded form, transmitted directly, and only decoded by the final recipient.</p></div><div id="rfc.section.8.4.1.p.2"><pre class="inline prettyprint lang-ietf_abnf prettyprinted" style=""><span id="rfc.iref.g.67"></span><span class="pln">  </span><a href="##content.codings" class="smpl"><span class="typ">content-coding</span></a><span class="pln">   </span><span class="pun">=</span><span class="pln"> </span><a href="##rule.token.separators" class="smpl"><span class="typ">token</span></a>
</pre></div><div id="rfc.section.8.4.1.p.3"><p>All content codings are case-insensitive and ought to be registered within the "HTTP Content Coding Registry", as described in <a href="##content.coding.extensibility" title="Content Coding Extensibility">Section 16.6</a> </p></div><div id="rfc.section.8.4.1.p.4"><p>Content-coding values are used in the <a href="##field.accept-encoding" class="smpl">Accept-Encoding</a> (<a href="##field.accept-encoding" id="rfc.xref.field.accept-encoding.1" title="Accept-Encoding">Section 12.5.3</a>) and <a href="##field.content-encoding" class="smpl">Content-Encoding</a> (<a href="##field.content-encoding" id="rfc.xref.field.content-encoding.1" title="Content-Encoding">Section 8.4</a>) header fields.</p></div><section id="compress.coding"><h5 id="rfc.section.8.4.1.1"><a href="##rfc.section.8.4.1.1">8.4.1.1.</a>&nbsp;<a href="##compress.coding">Compress Coding</a></h5><div id="rfc.section.8.4.1.1.p.1"><p>The "compress" coding is an adaptive Lempel-Ziv-Welch (LZW) coding <a href="##Welch" id="rfc.xref.Welch.1"><cite title="A Technique for High-Performance Data Compression">[Welch]</cite></a> that is commonly produced by the UNIX file compression program "compress". A recipient <em class="bcp14">SHOULD</em> consider "x-compress" to be equivalent to "compress".</p></div></section><section id="deflate.coding"><h5 id="rfc.section.8.4.1.2"><a href="##rfc.section.8.4.1.2">8.4.1.2.</a>&nbsp;<a href="##deflate.coding">Deflate Coding</a></h5><div id="rfc.section.8.4.1.2.p.1"><p>The "deflate" coding is a "zlib" data format <a href="##RFC1950" id="rfc.xref.RFC1950.1"><cite title="ZLIB Compressed Data Format Specification version 3.3">[RFC1950]</cite></a> containing a "deflate" compressed data stream <a href="##RFC1951" id="rfc.xref.RFC1951.1"><cite title="DEFLATE Compressed Data Format Specification version 1.3">[RFC1951]</cite></a> that uses a combination of the Lempel-Ziv (LZ77) compression algorithm and Huffman coding.</p></div><div id="rfc.section.8.4.1.2.p.2"><aside><div id="rfc.section.8.4.1.2.p.2.1"><p><b>Note:</b> Some non-conformant implementations send the "deflate" compressed data without the zlib wrapper.</p></div></aside></div></section><section id="gzip.coding"><h5 id="rfc.section.8.4.1.3"><a href="##rfc.section.8.4.1.3">8.4.1.3.</a>&nbsp;<a href="##gzip.coding">Gzip Coding</a></h5><div id="rfc.section.8.4.1.3.p.1"><p>The "gzip" coding is an LZ77 coding with a 32-bit Cyclic Redundancy Check (CRC) that is commonly produced by the gzip file compression program <a href="##RFC1952" id="rfc.xref.RFC1952.1"><cite title="GZIP file format specification version 4.3">[RFC1952]</cite></a>. A recipient <em class="bcp14">SHOULD</em> consider "x-gzip" to be equivalent to "gzip".</p></div></section></section></section><section id="field.content-language"><h3 id="rfc.section.8.5"><a href="##rfc.section.8.5">8.5.</a>&nbsp;<a href="##field.content-language">Content-Language</a></h3><div id="rfc.section.8.5.p.1"><p>The "Content-Language" header field describes the natural language(s) of the intended audience for the representation. Note that this might not be equivalent to all the languages used within the representation.</p></div><div id="rfc.section.8.5.p.2"><pre class="inline prettyprint lang-ietf_abnf prettyprinted" style=""><span id="rfc.iref.g.68"></span><span class="pln">  </span><a href="##field.content-language" class="smpl"><span class="typ">Content-Language</span></a><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">#</span><a href="##language.tags" class="smpl"><span class="typ">language-tag</span></a>
</pre></div><div id="rfc.section.8.5.p.3"><p>Language tags are defined in <a href="##language.tags" title="Language Tags">Section 8.5.1</a>. The primary purpose of Content-Language is to allow a user to identify and differentiate representations according to the users' own preferred language. Thus, if the content is intended only for a Danish-literate audience, the appropriate field is</p></div><div id="rfc.section.8.5.p.4"><pre class="text">Content-Language: da
</pre></div><div id="rfc.section.8.5.p.5"><p>If no Content-Language is specified, the default is that the content is intended for all language audiences. This might mean that the sender does not consider it to be specific to any natural language, or that the sender does not know for which language it is intended.</p></div><div id="rfc.section.8.5.p.6"><p>Multiple languages <em class="bcp14">MAY</em> be listed for content that is intended for multiple audiences. For example, a rendition of the "Treaty of Waitangi", presented simultaneously in the original Maori and English versions, would call for</p></div><div id="rfc.section.8.5.p.7"><pre class="text">Content-Language: mi, en
</pre></div><div id="rfc.section.8.5.p.8"><p>However, just because multiple languages are present within a representation does not mean that it is intended for multiple linguistic audiences. An example would be a beginner's language primer, such as "A First Lesson in Latin", which is clearly intended to be used by an English-literate audience. In this case, the Content-Language would properly only include "en".</p></div><div id="rfc.section.8.5.p.9"><p>Content-Language <em class="bcp14">MAY</em> be applied to any media type  it is not limited to textual documents.</p></div><section id="language.tags"><h4 id="rfc.section.8.5.1"><a href="##rfc.section.8.5.1">8.5.1.</a>&nbsp;<a href="##language.tags">Language Tags</a></h4><div id="rfc.section.8.5.1.p.1"><p>A language tag, as defined in <a href="##RFC5646" id="rfc.xref.RFC5646.1"><cite title="Tags for Identifying Languages">[RFC5646]</cite></a>, identifies a natural language spoken, written, or otherwise conveyed by human beings for communication of information to other human beings. Computer languages are explicitly excluded.</p></div><div id="rfc.section.8.5.1.p.2"><p>HTTP uses language tags within the <a href="##field.accept-language" class="smpl">Accept-Language</a> and <a href="##field.content-language" class="smpl">Content-Language</a> header fields. <a href="##field.accept-language" class="smpl">Accept-Language</a> uses the broader language-range production defined in <a href="##field.accept-language" id="rfc.xref.field.accept-language.1" title="Accept-Language">Section 12.5.4</a>, whereas <a href="##field.content-language" class="smpl">Content-Language</a> uses the language-tag production defined below.</p></div><div id="rfc.section.8.5.1.p.3"><pre class="inline prettyprint lang-ietf_abnf prettyprinted" style=""><span id="rfc.iref.g.69"></span><span class="pln">  </span><a href="##language.tags" class="smpl"><span class="typ">language-tag</span></a><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="nocode">&lt;Language-Tag, see </span><a href="##RFC5646" id="rfc.xref.RFC5646.2"><cite title="Tags for Identifying Languages"><span class="nocode">[RFC5646]</span></cite></a><span class="nocode">, </span><a href="https://www.rfc-editor.org/rfc/rfc5646.html#section-2.1"><span class="nocode">Section 2.1</span></a><span class="nocode">&gt;</span></pre></div><div id="rfc.section.8.5.1.p.4" class="avoidbreakafter"><p>A language tag is a sequence of one or more case-insensitive subtags, each separated by a hyphen character ("-", %x2D). In most cases, a language tag consists of a primary language subtag that identifies a broad family of related languages (e.g., "en" = English), which is optionally followed by a series of subtags that refine or narrow that language's range (e.g., "en-CA" = the variety of English as communicated in Canada). Whitespace is not allowed within a language tag. Example tags include:</p></div><div id="rfc.section.8.5.1.p.5"><pre class="text">  fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
</pre></div><div id="rfc.section.8.5.1.p.6"><p>See <a href="##RFC5646" id="rfc.xref.RFC5646.3"><cite title="Tags for Identifying Languages">[RFC5646]</cite></a> for further information.</p></div></section></section><section id="field.content-length"><h3 id="rfc.section.8.6"><a href="##rfc.section.8.6">8.6.</a>&nbsp;<a href="##field.content-length">Content-Length</a></h3><div id="rfc.section.8.6.p.1"><p>The "Content-Length" header field indicates the associated representation's data length as a decimal non-negative integer number of octets. When transferring a representation as content, Content-Length refers specifically to the amount of data enclosed so that it can be used to delimit framing (e.g., <a href="https://httpwg.org/specs/rfc9112.html#body.content-length" title="Content-Length">Section 6.2</a> of <a href="##HTTP11" id="rfc.xref.HTTP11.16"><cite title="HTTP/1.1">[HTTP/1.1]</cite></a>). In other cases, Content-Length indicates the selected representation's current length, which can be used by recipients to estimate transfer time or to compare with previously stored representations.</p></div><div id="rfc.section.8.6.p.2"><pre class="inline prettyprint lang-ietf_abnf prettyprinted" style=""><span id="rfc.iref.g.70"></span><span class="pln">  </span><a href="##field.content-length" class="smpl"><span class="typ">Content-Length</span></a><span class="pln"> </span><span class="pun">=</span><span class="pln"> 1</span><span class="pun">*</span><a href="##core.rules" class="smpl"><span class="typ">DIGIT</span></a>
</pre></div><div id="rfc.section.8.6.p.3"><p>An example is</p></div><div id="rfc.section.8.6.p.4"><pre class="text">Content-Length: 3495
</pre></div><div id="rfc.section.8.6.p.5"><p>A user agent <em class="bcp14">SHOULD</em> send Content-Length in a request when the method defines a meaning for enclosed content and it is not sending <a href="https://httpwg.org/specs/rfc9112.html#field.transfer-encoding" class="smpl">Transfer-Encoding</a>. For example, a user agent normally sends Content-Length in a POST request even when the value is 0 (indicating empty content). A user agent <em class="bcp14">SHOULD NOT</em> send a Content-Length header field when the request message does not contain content and the method semantics do not anticipate such data.</p></div><div id="rfc.section.8.6.p.6"><p>A server <em class="bcp14">MAY</em> send a Content-Length header field in a response to a HEAD request (<a href="##HEAD" id="rfc.xref.HEAD.2" title="HEAD">Section 9.3.2</a>); a server <em class="bcp14">MUST NOT</em> send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a response if the same request had used the GET method.</p></div><div id="rfc.section.8.6.p.7"><p>A server <em class="bcp14">MAY</em> send a Content-Length header field in a <a href="##status.304" class="smpl">304 (Not Modified)</a> response to a conditional GET request (<a href="##status.304" id="rfc.xref.status.304.1" title="304 Not Modified">Section 15.4.5</a>); a server <em class="bcp14">MUST NOT</em> send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a <a href="##status.200" class="smpl">200 (OK)</a> response to the same request.</p></div><div id="rfc.section.8.6.p.8"><p>A server <em class="bcp14">MUST NOT</em> send a Content-Length header field in any response with a status code of <a href="##status.1xx" class="smpl">1xx (Informational)</a> or <a href="##status.204" class="smpl">204 (No Content)</a>. A server <em class="bcp14">MUST NOT</em> send a Content-Length header field in any <a href="##status.2xx" class="smpl">2xx (Successful)</a> response to a CONNECT request (<a href="##CONNECT" id="rfc.xref.CONNECT.4" title="CONNECT">Section 9.3.6</a>).</p></div><div id="rfc.section.8.6.p.9"><p>Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server <em class="bcp14">SHOULD</em> send a Content-Length header field when the content size is known prior to sending the complete header section. This will allow downstream recipients to measure transfer progress, know when a received message is complete, and potentially reuse the connection for additional requests.</p></div><div id="rfc.section.8.6.p.10"><p>Any Content-Length field value greater than or equal to zero is valid. Since there is no predefined limit to the length of content, a recipient <em class="bcp14">MUST</em> anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer conversion (<a href="##attack.protocol.element.length" title="Attacks via Protocol Element Length">Section 17.5</a>).</p></div><div id="rfc.section.8.6.p.11"><p>Because Content-Length is used for message delimitation in HTTP/1.1, its field value can impact how the message is parsed by downstream recipients even when the immediate connection is not using HTTP/1.1. If the message is forwarded by a downstream intermediary, a Content-Length field value that is inconsistent with the received message framing might cause a security failure due to request smuggling or response splitting.</p></div><div id="rfc.section.8.6.p.12"><p>As a result, a sender <em class="bcp14">MUST NOT</em> forward a message with a Content-Length header field value that is known to be incorrect.</p></div><div id="rfc.section.8.6.p.13"><p>Likewise, a sender <em class="bcp14">MUST NOT</em> forward a message with a Content-Length header field value that does not match the ABNF above, with one exception: a recipient of a Content-Length header field value consisting of the same decimal value repeated as a comma-separated list (e.g, "Content-Length: 42, 42") <em class="bcp14">MAY</em> either reject the message as invalid or replace that invalid field value with a single instance of the decimal value, since this likely indicates that a duplicate was generated or combined by an upstream message processor.</p></div></section><section id="field.content-location"><h3 id="rfc.section.8.7"><a href="##rfc.section.8.7">8.7.</a>&nbsp;<a href="##field.content-location">Content-Location</a></h3><div id="rfc.section.8.7.p.1"><p>The "Content-Location" header field references a URI that can be used as an identifier for a specific resource corresponding to the representation in this message's content. In other words, if one were to perform a GET request on this URI at the time of this message's generation, then a <a href="##status.200" class="smpl">200 (OK)</a> response would contain the same representation that is enclosed as content in this message.</p></div><div id="rfc.section.8.7.p.2"><pre class="inline prettyprint lang-ietf_abnf prettyprinted" style=""><span id="rfc.iref.g.71"></span><span class="pln">  </span><a href="##field.content-location" class="smpl"><span class="typ">Content-Location</span></a><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><a href="##uri.references" class="smpl"><span class="typ">absolute-URI</span></a><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><a href="##uri.references" class="smpl"><span class="typ">partial-URI</span></a>
</pre></div><div id="rfc.section.8.7.p.3"><p>The field value is either an <a href="##uri.references" class="smpl">absolute-URI</a> or a <a href="##uri.references" class="smpl">partial-URI</a>. In the latter case (<a href="##uri" title="Identifiers in HTTP">Section 4</a>), the referenced URI is relative to the target URI (<a href="##URI" id="rfc.xref.URI.27"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[URI]</cite></a>, <a href="https://www.rfc-editor.org/rfc/rfc3986.html#section-5">Section 5</a>).</p></div><div id="rfc.section.8.7.p.4"><p>The Content-Location value is not a replacement for the target URI (<a href="##target.resource" title="Determining the Target Resource">Section 7.1</a>). It is representation metadata. It has the same syntax and semantics as the header field of the same name defined for MIME body parts in <a href="https://www.rfc-editor.org/rfc/rfc2557.html#section-4">Section 4</a> of <a href="##RFC2557" id="rfc.xref.RFC2557.1"><cite title="MIME Encapsulation of Aggregate Documents, such as HTML (MHTML)">[RFC2557]</cite></a>. However, its appearance in an HTTP message has some special implications for HTTP recipients.</p></div><div id="rfc.section.8.7.p.5"><p>If Content-Location is included in a <a href="##status.2xx" class="smpl">2xx (Successful)</a> response message and its value refers (after conversion to absolute form) to a URI that is the same as the target URI, then the recipient <em class="bcp14">MAY</em> consider the content to be a current representation of that resource at the time indicated by the message origination date. For a GET (<a href="##GET" id="rfc.xref.GET.5" title="GET">Section 9.3.1</a>) or HEAD (<a href="##HEAD" id="rfc.xref.HEAD.3" title="HEAD">Section 9.3.2</a>) request, this is the same as the default semantics when no Content-Location is provided by the server. For a state-changing request like PUT (<a href="##PUT" id="rfc.xref.PUT.2" title="PUT">Section 9.3.4</a>) or POST (<a href="##POST" id="rfc.xref.POST.2" title="POST">Section 9.3.3</a>), it implies that the server's response contains the new representation of that resource, thereby distinguishing it from representations that might only report about the action (e.g., "It worked!"). This allows authoring applications to update their local copies without the need for a subsequent GET request.</p></div><div id="rfc.section.8.7.p.6"><p>If Content-Location is included in a <a href="##status.2xx" class="smpl">2xx (Successful)</a> response message and its field value refers to a URI that differs from the target URI, then the origin server claims that the URI is an identifier for a different resource corresponding to the enclosed representation. Such a claim can only be trusted if both identifiers share the same resource owner, which cannot be programmatically determined via HTTP.</p></div><div id="rfc.section.8.7.p.7"><ul><li>For a response to a GET or HEAD request, this is an indication that the target URI refers to a resource that is subject to content negotiation and the Content-Location field value is a more specific identifier for the <a href="##selected.representation" class="smpl">selected representation</a>.</li><li>For a <a href="##status.201" class="smpl">201 (Created)</a> response to a state-changing method, a Content-Location field value that is identical to the <a href="##field.location" class="smpl">Location</a> field value indicates that this content is a current representation of the newly created resource.</li><li>Otherwise, such a Content-Location indicates that this content is a representation reporting on the requested action's status and that the same report is available (for future access with GET) at the given URI. For example, a purchase transaction made via a POST request might include a receipt document as the content of the <a href="##status.200" class="smpl">200 (OK)</a> response; the Content-Location field value provides an identifier for retrieving a copy of that same receipt in the future.</li></ul></div><div id="rfc.section.8.7.p.8"><p>A user agent that sends Content-Location in a request message is stating that its value refers to where the user agent originally obtained the content of the enclosed representation (prior to any modifications made by that user agent). In other words, the user agent is providing a back link to the source of the original representation.</p></div><div id="rfc.section.8.7.p.9"><p>An origin server that receives a Content-Location field in a request message <em class="bcp14">MUST</em> treat the information as transitory request context rather than as metadata to be saved verbatim as part of the representation. An origin server <em class="bcp14">MAY</em> use that context to guide in processing the request or to save it for other uses, such as within source links or versioning metadata. However, an origin server <em class="bcp14">MUST NOT</em> use such context information to alter the request semantics.</p></div><div id="rfc.section.8.7.p.10"><p>For example, if a client makes a PUT request on a negotiated resource and the origin server accepts that PUT (without redirection), then the new state of that resource is expected to be consistent with the one representation supplied in that PUT; the Content-Location cannot be used as a form of reverse content selection identifier to update only one of the negotiated representations. If the user agent had wanted the latter semantics, it would have applied the PUT directly to the Content-Location URI.</p></div></section><section id="response.validator"><h3 id="rfc.section.8.8"><a href="##rfc.section.8.8">8.8.</a>&nbsp;<a href="##response.validator">Validator Fields</a></h3><div id="rfc.section.8.8.p.1"><p>Resource metadata is referred to as a <dfn>validator</dfn> if it can be used within a precondition (<a href="##preconditions" title="Preconditions">Section 13.1</a>) to make a conditional request (<a href="##conditional.requests" title="Conditional Requests">Section 13</a>). Validator fields convey a current validator for the <a href="##selected.representation" class="smpl">selected representation</a> (<a href="##representations" title="Representations">Section 3.2</a>).</p></div><div id="rfc.section.8.8.p.2"><p>In responses to safe requests, validator fields describe the selected representation chosen by the origin server while handling the response. Note that, depending on the method and status code semantics, the selected representation for a given response is not necessarily the same as the representation enclosed as response content.</p></div><div id="rfc.section.8.8.p.3"><p>In a successful response to a state-changing request, validator fields describe the new representation that has replaced the prior <a href="##selected.representation" class="smpl">selected representation</a> as a result of processing the request.</p></div><div id="rfc.section.8.8.p.4"><p>For example, an ETag field in a <a href="##status.201" class="smpl">201 (Created)</a> response communicates the entity tag of the newly created resource's representation, so that the entity tag can be used as a validator in later conditional requests to prevent the "lost update" problem.</p></div><div id="rfc.section.8.8.p.5"><p>This specification defines two forms of metadata that are commonly used to observe resource state and test for preconditions: modification dates (<a href="##field.last-modified" id="rfc.xref.field.last-modified.1" title="Last-Modified">Section 8.8.2</a>) and opaque entity tags (<a href="##field.etag" id="rfc.xref.field.etag.1" title="ETag">Section 8.8.3</a>). Additional metadata that reflects resource state has been defined by various extensions of HTTP, such as Web Distributed Authoring and Versioning <a href="##WEBDAV" id="rfc.xref.WEBDAV.1"><cite title="HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)">[WEBDAV]</cite></a>, that are beyond the scope of this specification.</p></div><section id="weak.and.strong.validators"><h4 id="rfc.section.8.8.1"><a href="##rfc.section.8.8.1">8.8.1.</a>&nbsp;<a href="##weak.and.strong.validators">Weak versus Strong</a></h4><div id="rfc.section.8.8.1.p.1"><p>Validators come in two flavors: strong or weak. Weak validators are easy to generate but are far less useful for comparisons. Strong validators are ideal for comparisons but can be very difficult (and occasionally impossible) to generate efficiently. Rather than impose that all forms of resource adhere to the same strength of validator, HTTP exposes the type of validator in use and imposes restrictions on when weak validators can be used as preconditions.</p></div><div id="rfc.section.8.8.1.p.2"><p>A <dfn>strong validator</dfn> is representation metadata that changes value whenever a change occurs to the representation data that would be observable in the content of a <a href="##status.200" class="smpl">200 (OK)</a> response to GET.</p></div><div id="rfc.section.8.8.1.p.3"><p>A strong validator might change for reasons other than a change to the representation data, such as when a semantically significant part of the representation metadata is changed (e.g., <a href="##field.content-type" class="smpl">Content-Type</a>), but it is in the best interests of the origin server to only change the value when it is necessary to invalidate the stored responses held by remote caches and authoring tools.</p></div><div id="rfc.section.8.8.1.p.4"><p>Cache entries might persist for arbitrarily long periods, regardless of expiration times. Thus, a cache might attempt to validate an entry using a validator that it obtained in the distant past. A strong validator is unique across all versions of all representations associated with a particular resource over time. However, there is no implication of uniqueness across representations of different resources (i.e., the same strong validator might be in use for representations of multiple resources at the same time and does not imply that those representations are equivalent).</p></div><div id="rfc.section.8.8.1.p.5"><p>There are a variety of strong validators used in practice. The best are based on strict revision control, wherein each change to a representation always results in a unique node name and revision identifier being assigned before the representation is made accessible to GET. A collision-resistant hash function applied to the representation data is also sufficient if the data is available prior to the response header fields being sent and the digest does not need to be recalculated every time a validation request is received. However, if a resource has distinct representations that differ only in their metadata, such as might occur with content negotiation over media types that happen to share the same data format, then the origin server needs to incorporate additional information in the validator to distinguish those representations.</p></div><div id="rfc.section.8.8.1.p.6"><p>In contrast, a <dfn>weak validator</dfn> is representation metadata that might not change for every change to the representation data. This weakness might be due to limitations in how the value is calculated (e.g., clock resolution), an inability to ensure uniqueness for all possible representations of the resource, or a desire of the resource owner to group representations by some self-determined set of equivalency rather than unique sequences of data.</p></div><div id="rfc.section.8.8.1.p.7"><p>An origin server <em class="bcp14">SHOULD</em> change a weak entity tag whenever it considers prior representations to be unacceptable as a substitute for the current representation. In other words, a weak entity tag ought to change whenever the origin server wants caches to invalidate old responses.</p></div><div id="rfc.section.8.8.1.p.8"><p>For example, the representation of a weather report that changes in content every second, based on dynamic measurements, might be grouped into sets of equivalent representations (from the origin server's perspective) with the same weak validator in order to allow cached representations to be valid for a reasonable period of time (perhaps adjusted dynamically based on server load or weather quality). Likewise, a representation's modification time, if defined with only one-second resolution, might be a weak validator if it is possible for the representation to be modified twice during a single second and retrieved between those modifications.</p></div><div id="rfc.section.8.8.1.p.9"><p>Likewise, a validator is weak if it is shared by two or more representations of a given resource at the same time, unless those representations have identical representation data. For example, if the origin server sends the same validator for a representation with a gzip content coding applied as it does for a representation with no content coding, then that validator is weak. However, two simultaneous representations might share the same strong validator if they differ only in the representation metadata, such as when two different media types are available for the same representation data.</p></div><div id="rfc.section.8.8.1.p.10"><p>Strong validators are usable for all conditional requests, including cache validation, partial content ranges, and "lost update" avoidance. Weak validators are only usable when the client does not require exact equality with previously obtained representation data, such as when validating a cache entry or limiting a web traversal to recent changes.</p></div></section><section id="field.last-modified"><h4 id="rfc.section.8.8.2"><a href="##rfc.section.8.8.2">8.8.2.</a>&nbsp;<a href="##field.last-modified">Last-Modified</a></h4><div id="rfc.section.8.8.2.p.1"><p>The "Last-Modified" header field in a response provides a timestamp indicating the date and time at which the origin server believes the <a href="##selected.representation" class="smpl">selected representation</a> was last modified, as determined at the conclusion of handling the request.</p></div><div id="rfc.section.8.8.2.p.2"><pre class="inline prettyprint lang-ietf_abnf prettyprinted" style=""><span id="rfc.iref.g.72"></span><span class="pln">  </span><a href="##field.last-modified" class="smpl"><span class="typ">Last-Modified</span></a><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><a href="##http.date" class="smpl"><span class="typ">HTTP-date</span></a>
</pre></div><div id="rfc.section.8.8.2.p.3"><p>An example of its use is</p></div><div id="rfc.section.8.8.2.p.4"><pre class="text">Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
</pre></div><section id="lastmod.generation"><h5 id="rfc.section.8.8.2.1"><a href="##rfc.section.8.8.2.1">8.8.2.1.</a>&nbsp;<a href="##lastmod.generation">Generation</a></h5><div id="rfc.section.8.8.2.1.p.1"><p>An origin server <em class="bcp14">SHOULD</em> send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness (<a href="##CACHING" id="rfc.xref.CACHING.10"><cite title="HTTP Caching">[CACHING]</cite></a>) can substantially reduce unnecessary transfers and significantly improve service availability and scalability.</p></div><div id="rfc.section.8.8.2.1.p.2"><p>A representation is typically the sum of many parts behind the resource interface. The last-modified time would usually be the most recent time that any of those parts were changed. How that value is determined for any given resource is an implementation detail beyond the scope of this specification.</p></div><div id="rfc.section.8.8.2.1.p.3"><p>An origin server <em class="bcp14">SHOULD</em> obtain the Last-Modified value of the representation as close as possible to the time that it generates the <a href="##field.date" class="smpl">Date</a> field value for its response. This allows a recipient to make an accurate assessment of the representation's modification time, especially if the representation changes near the time that the response is generated.</p></div><div id="rfc.section.8.8.2.1.p.4"><p>An origin server with a clock (as defined in <a href="##http.date" title="Date/Time Formats">Section 5.6.7</a>) <em class="bcp14">MUST NOT</em> generate a Last-Modified date that is later than the server's time of message origination (<a href="##field.date" class="smpl">Date</a>, <a href="##field.date" id="rfc.xref.field.date.3" title="Date">Section 6.6.1</a>). If the last modification time is derived from implementation-specific metadata that evaluates to some time in the future, according to the origin server's clock, then the origin server <em class="bcp14">MUST</em> replace that value with the message origination date. This prevents a future modification date from having an adverse impact on cache validation.</p></div><div id="rfc.section.8.8.2.1.p.5"><p>An origin server without a clock <em class="bcp14">MUST NOT</em> generate a Last-Modified date for a response unless that date value was assigned to the resource by some other system (presumably one with a clock).</p></div></section><section id="lastmod.comparison"><h5 id="rfc.section.8.8.2.2"><a href="##rfc.section.8.8.2.2">8.8.2.2.</a>&nbsp;<a href="##lastmod.comparison">Comparison</a></h5><div id="rfc.section.8.8.2.2.p.1" class="avoidbreakafter"><p>A Last-Modified time, when used as a validator in a request, is implicitly weak unless it is possible to deduce that it is strong, using the following rules:</p></div><div id="rfc.section.8.8.2.2.p.2"><ul><li>The validator is being compared by an origin server to the actual current validator for the representation and,</li><li>That origin server reliably knows that the associated representation did not change twice during the second covered by the presented validator;</li></ul></div><div id="rfc.section.8.8.2.2.p.3"><p>or</p></div><div id="rfc.section.8.8.2.2.p.4"><ul><li>The validator is about to be used by a client in an <a href="##field.if-modified-since" class="smpl">If-Modified-Since</a>, <a href="##field.if-unmodified-since" class="smpl">If-Unmodified-Since</a>, or <a href="##field.if-range" class="smpl">If-Range</a> header field, because the client has a cache entry for the associated representation, and</li><li>That cache entry includes a <a href="##field.date" class="smpl">Date</a> value which is at least one second after the Last-Modified value and the client has reason to believe that they were generated by the same clock or that there is enough difference between the Last-Modified and Date values to make clock synchronization issues unlikely;</li></ul></div><div id="rfc.section.8.8.2.2.p.5"><p>or</p></div><div id="rfc.section.8.8.2.2.p.6"><ul><li>The validator is being compared by an intermediate cache to the validator stored in its cache entry for the representation, and</li><li>That cache entry includes a <a href="##field.date" class="smpl">Date</a> value which is at least one second after the Last-Modified value and the cache has reason to believe that they were generated by the same clock or that there is enough difference between the Last-Modified and Date values to make clock synchronization issues unlikely.</li></ul></div><div id="rfc.section.8.8.2.2.p.7"><p>This method relies on the fact that if two different responses were sent by the origin server during the same second, but both had the same Last-Modified time, then at least one of those responses would have a <a href="##field.date" class="smpl">Date</a> value equal to its Last-Modified time.</p></div></section></section><section id="field.etag"><h4 id="rfc.section.8.8.3"><a href="##rfc.section.8.8.3">8.8.3.</a>&nbsp;<a href="##field.etag">ETag</a></h4><div id="rfc.section.8.8.3.p.1"><p>The "ETag" field in a response provides the current entity tag for the <a href="##selected.representation" class="smpl">selected representation</a>, as determined at the conclusion of handling the request. An entity tag is an opaque validator for differentiating between multiple representations of the same resource, regardless of whether those multiple representations are due to resource state changes over time, content negotiation resulting in multiple representations being valid at the same time, or both. An entity tag consists of an opaque quoted string, possibly prefixed by a weakness indicator.</p></div><div id="rfc.section.8.8.3.p.2"><pre class="inline prettyprint lang-ietf_abnf prettyprinted" style=""><span id="rfc.iref.g.73"></span><span id="rfc.iref.g.74"></span><span id="rfc.iref.g.75"></span><span id="rfc.iref.g.76"></span><span id="rfc.iref.g.77"></span><span class="pln">  </span><a href="##field.etag" class="smpl"><span class="typ">ETag</span></a><span class="pln">       </span><span class="pun">=</span><span class="pln"> </span><a href="##field.etag" class="smpl"><span class="typ">entity-tag</span></a><span class="pln">

  </span><a href="##field.etag" class="smpl"><span class="typ">entity-tag</span></a><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="pln"> </span><a href="##field.etag" class="smpl"><span class="typ">weak</span></a><span class="pln"> </span><span class="pun">]</span><span class="pln"> </span><a href="##field.etag" class="smpl"><span class="typ">opaque-tag</span></a><span class="pln">
  </span><a href="##field.etag" class="smpl"><span class="typ">weak</span></a><span class="pln">       </span><span class="pun">=</span><span class="pln"> </span><span class="str">%s"W/"</span><span class="pln">
  </span><a href="##field.etag" class="smpl"><span class="typ">opaque-tag</span></a><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><a href="##core.rules" class="smpl"><span class="typ">DQUOTE</span></a><span class="pln"> </span><span class="pun">*</span><a href="##field.etag" class="smpl"><span class="typ">etagc</span></a><span class="pln"> </span><a href="##core.rules" class="smpl"><span class="typ">DQUOTE</span></a><span class="pln">
  </span><a href="##field.etag" class="smpl"><span class="typ">etagc</span></a><span class="pln">      </span><span class="pun">=</span><span class="pln"> </span><span class="lit">%x21</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="lit">%x23-7E</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><a href="##fields.values" class="smpl"><span class="typ">obs-text</span></a><span class="pln">
             </span><span class="com">; </span><a href="##core.rules" class="smpl"><span class="com">VCHAR</span></a><span class="com"> except double quotes, plus obs-text</span></pre></div><div id="rfc.section.8.8.3.p.3"><aside><div id="rfc.section.8.8.3.p.3.1"><p><b>Note:</b> Previously, opaque-tag was defined to be a quoted-string (<a href="##RFC2616" id="rfc.xref.RFC2616.2"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2616]</cite></a>, <a href="https://www.rfc-editor.org/rfc/rfc2616.html#section-3.11">Section 3.11</a>); thus, some recipients might perform backslash unescaping. Servers therefore ought to avoid backslash characters in entity tags.</p></div></aside></div><div id="rfc.section.8.8.3.p.4"><p>An entity tag can be more reliable for validation than a modification date in situations where it is inconvenient to store modification dates, where the one-second resolution of HTTP-date values is not sufficient, or where modification dates are not consistently maintained.</p></div><div id="rfc.section.8.8.3.p.5" class="avoidbreakafter"><p>Examples:</p></div><div id="rfc.section.8.8.3.p.6"><pre class="text">ETag: "xyzzy"
ETag: W/"xyzzy"
ETag: ""
</pre></div>